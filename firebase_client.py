"""Utilities for authenticating users and fetching profile data from Firebase.

This module now carries the production Firebase configuration that powers the
deployed Watt Weaver application so the Streamlit UI can surface it directly to
the user.  The ``DEFAULT_FIREBASE_WEB_CONFIG`` dictionary mirrors the snippet
shown in the Firebase console when registering the web application, while the
``FIREBASE_FIRESTORE_RULES`` string contains the Firestore security rules you
can paste into the Firebase console.

If you prefer to override any of the values, export environment variables such
as ``FIREBASE_API_KEY`` or provide them through Streamlit secrets; otherwise the
defaults below will be used automatically.
"""

from __future__ import annotations

import importlib
import importlib.util
import json
import os
from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple

import requests

# Default Firebase project configuration used by the Watt Weaver deployment.
# These values match the JavaScript configuration snippet generated by the
# Firebase console for the "watt-weaver" project.
DEFAULT_FIREBASE_WEB_CONFIG = {
    "apiKey": "AIzaSyCJe-wrDN4ks81iHjayL36hAmfeQsx_RWk",
    "authDomain": "watt-weaver.firebaseapp.com",
    "projectId": "watt-weaver",
    "storageBucket": "watt-weaver.firebasestorage.app",
    "messagingSenderId": "107198469271",
    "appId": "1:107198469271:web:8f0a36e0e02109984e45d2",
    "measurementId": "G-RPB4T518S8",
}

# Mapping of environment-variable names used by the Python code to the values
# in the Firebase web configuration snippet.  ``FIREBASE_USERS_COLLECTION`` is
# included for completeness; it defaults to ``users`` for the login experience.
DEFAULT_FIREBASE_CONFIG = {
    "FIREBASE_API_KEY": DEFAULT_FIREBASE_WEB_CONFIG["apiKey"],
    "FIREBASE_PROJECT_ID": DEFAULT_FIREBASE_WEB_CONFIG["projectId"],
    "FIREBASE_AUTH_DOMAIN": DEFAULT_FIREBASE_WEB_CONFIG["authDomain"],
    "FIREBASE_STORAGE_BUCKET": DEFAULT_FIREBASE_WEB_CONFIG["storageBucket"],
    "FIREBASE_MESSAGING_SENDER_ID": DEFAULT_FIREBASE_WEB_CONFIG["messagingSenderId"],
    "FIREBASE_APP_ID": DEFAULT_FIREBASE_WEB_CONFIG["appId"],
    "FIREBASE_MEASUREMENT_ID": DEFAULT_FIREBASE_WEB_CONFIG["measurementId"],
    "FIREBASE_USERS_COLLECTION": "users",
}

# Firestore security rules that allow each authenticated user to read and write
# their own profile document stored under ``/users/{uid}``.
FIREBASE_FIRESTORE_RULES = """
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
""".strip()


class FirebaseConfigError(RuntimeError):
    """Raised when the Firebase configuration is incomplete."""


class FirebaseAuthError(RuntimeError):
    """Raised when authentication against Firebase fails."""


class FirebaseDatabaseError(RuntimeError):
    """Raised when a Firebase database request cannot be completed."""


@dataclass
class FirebaseUser:
    """Represents the minimal information returned by Firebase Authentication."""

    email: str
    local_id: str
    id_token: str
    refresh_token: str

def _load_streamlit() -> Tuple[Optional[Any], Optional[type]]:
    """Return the Streamlit module and its secret-not-found error class."""

    if importlib.util.find_spec("streamlit") is None:
        return None, None

    streamlit = importlib.import_module("streamlit")

    errors_spec = importlib.util.find_spec("streamlit.errors")
    secret_error: Optional[type] = None
    if errors_spec is not None:
        errors_module = importlib.import_module("streamlit.errors")
        secret_error = getattr(errors_module, "StreamlitSecretNotFoundError", None)

    return streamlit, secret_error


def _get_required_setting(name: str) -> str:
    """Return an environment variable or raise a configuration error."""

    value = os.getenv(name)
    if not value:
        streamlit, secret_error = _load_streamlit()
        if streamlit is not None:
            secrets_value = None
            try:
                secrets_value = streamlit.secrets.get(name)
            except Exception as exc:  # pragma: no cover - secrets not configured
                if secret_error is not None and isinstance(exc, secret_error):
                    secrets_value = None
                elif exc.__class__.__name__ == "StreamlitSecretNotFoundError":
                    secrets_value = None
                else:
                    raise
            if secrets_value:
                value = str(secrets_value)
    if not value:
        value = DEFAULT_FIREBASE_CONFIG.get(name)
    if not value:
        raise FirebaseConfigError(
            f"Missing required Firebase configuration value: {name}. "
            "Set it as an environment variable before launching the app."
        )
    return value


def validate_settings() -> None:
    """Validate that the minimum Firebase settings are available."""

    _get_required_setting("FIREBASE_API_KEY")
    _get_required_setting("FIREBASE_PROJECT_ID")


def authenticate_user(email: str, password: str) -> FirebaseUser:
    """Authenticate an email/password pair with Firebase Authentication."""

    api_key = _get_required_setting("FIREBASE_API_KEY")
    url = (
        "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword"
        f"?key={api_key}"
    )
    payload = {
        "email": email,
        "password": password,
        "returnSecureToken": True,
    }

    try:
        response = requests.post(url, json=payload, timeout=10)
    except requests.RequestException as exc:  # pragma: no cover - network failure
        raise FirebaseAuthError("Unable to reach Firebase Authentication service.") from exc

    data = response.json()
    if response.status_code != 200:
        message = data.get("error", {}).get("message", "Authentication failed")
        raise FirebaseAuthError(message)

    return FirebaseUser(
        email=data["email"],
        local_id=data["localId"],
        id_token=data["idToken"],
        refresh_token=data["refreshToken"],
    )


def _simplify_firestore_fields(fields: Dict[str, Any]) -> Dict[str, Any]:
    """Convert Firestore's typed field representation into plain values."""

    simplified: Dict[str, Any] = {}
    for key, value in fields.items():
        if not isinstance(value, dict):
            simplified[key] = value
            continue
        # Firestore stores a single key describing the value type.
        type_key, type_value = next(iter(value.items()))
        if type_key.endswith("Value"):
            simplified[key] = type_value
        else:
            simplified[key] = value
    return simplified


def fetch_user_profile(
    local_id: str,
    id_token: str,
    collection: Optional[str] = None,
) -> Optional[Dict[str, Any]]:
    """Fetch a user's profile document from Firestore.

    The document is expected to live at ``/{collection}/{local_id}`` and will be
    returned as a dictionary with its Firestore-typed fields simplified.
    """

    project_id = _get_required_setting("FIREBASE_PROJECT_ID")
    collection_name = collection or os.getenv("FIREBASE_USERS_COLLECTION", "users")

    document_path = (
        "https://firestore.googleapis.com/v1/projects/"
        f"{project_id}/databases/(default)/documents/"
        f"{collection_name}/{local_id}"
    )

    headers = {"Authorization": f"Bearer {id_token}"}

    try:
        response = requests.get(document_path, headers=headers, timeout=10)
    except requests.RequestException as exc:  # pragma: no cover - network failure
        raise FirebaseDatabaseError("Unable to reach Firestore API.") from exc

    if response.status_code == 404:
        return None

    if response.status_code != 200:
        data = response.json()
        message = data.get("error", {}).get("message", "Failed to read Firestore document")
        raise FirebaseDatabaseError(message)

    document = response.json()
    fields = document.get("fields")
    if not fields:
        return {}

    return _simplify_firestore_fields(fields)


def export_web_config() -> str:
    """Return the default Firebase web configuration as formatted JSON."""

    return json.dumps(DEFAULT_FIREBASE_WEB_CONFIG, indent=2)


def export_firestore_rules() -> str:
    """Return the default Firestore security rules."""

    return FIREBASE_FIRESTORE_RULES

